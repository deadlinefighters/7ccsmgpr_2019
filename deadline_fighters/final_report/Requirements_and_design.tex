\section{System Design}
\subsection{Introduction}
The team \emph{Deadline Fighters} was given the overall requirement to build a \emph{hub and spoke} file synchroniser which has a single central server (the \emph{hub}) to which multiple other clients (the \emph{spokes}) can synchronise. The following are the operations that it entails and the priority of implementation we set for our team.

\bgroup
\def\arraystretch{1.3}
\begin{table}[H]
\centering
\begin{tabular}{|c|m{8cm}|c|c|}
\hline
Client name & User role & Priority & Description\\
\hline
{Desktop and Mobile} & View files on the server & 2 &{Priority description:} \\
\cline{2-3}
& Upload a file from local which is outside the local sync folder (only for Android)& 1&{}  \\
\cline{2-3}
& Upload a single file from local sync folder & 2&{\textbf{1-Highest priority}}\\
\cline{2-3}
& Upload multiple files from local sync folder & 2&{}\\
\cline{2-3}
&Download a single file from server & 1 &{(Important /necessary functions)}\\
\cline{2-3}
&Download multiple files from server & 2&{}\\
\cline{2-3}
&Reflect delete of a single file (Local to server) & 2&{}\\
\cline{2-3}
&Reflect delete of a single file (Server to local) & 2&{\textbf{4-Lowest priority}}\\
\cline{2-3}
&Reflect delete of multiple files (Local to server) & 3 &{}\\
\cline{2-3}
&Reflect delete of multiple files (Server to local) & 3&{(Will implement if time permits)}\\
\cline{2-3}
&Reflect rename (Local to server) & 2&{}\\
\cline{2-3}
&Reflect rename (Server to local) & 3&{}\\
\cline{2-3}
&Download edited changes on a single file from server & 3&{}\\
\cline{2-3}
&Download changes on two or more files from server & 4&{}\\
\cline{2-3}
&Synchronize all server and local files & 2&{}\\
\hline
\bottomrule
\end{tabular}
\caption{Functionalities to be enabled on client applications}
\end{table}
\egroup


\subsection{Architecture}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Architecture}
\caption{Flow of operation across client, server and AWS S3}
\end{figure}

Our desktop and mobile clients sends a custom POST request to the DeadlineFighters Python server based on the operation and file involved. The server then interprets the call and makes necessary presigned URL fetch call to our AWS S3 bucket which serves as our cloud storage. The server then passes on the fetch URL to the application. The application now makes necessary HTTP call to the URL based on the operation and payload.\newline

All interactions between the application and the server happens as HTTP requests with JSON request/response body. Using Python server as a proxy to AWS S3 instead of directing interacting with S3 was a decision made after the preliminary presentation. This is in par with industry standards where applications use S3 and other cloud storage but the client applications are unaware of it. This allows for future migration to other cloud endpoint if necessary.\newline

\subsection{Conflict resolution}
We also leverage the ETag generated by AWS for each file to check the version of the file and detect conflict. We have implemented Sqlite Database on the server which updates its rows with (filename, eTag and lastModified) values upon every upload/download request from client. This helps in detecting potential conflict.\newline

The client will have a Database that has the same schema but the eTag will be the last known eTag for the file. This eTag is sent along with the request to the server. The server compares the eTag sent by the client and the one it has from S3. If they match, it indicates no conflict. If they do not, a conflict window will be popped with options for users to upload local copy, download server copy (both by force) or keep two copies of the file.\newline

At the time of this report submission, development of conflict resolution on desktop client is underway. Conflict resolution will not be implemented on Android during the project timeline.\newline